"""                            Лабораторна работа номер 1
                          з курсу Чисельні методи, варіант 6
    Завдання: Для ряду f(x)= обчислити його наближене значення при х[0,1] з кроком h=0.05.
    Обчислення припинити, якщо |ai|<eps=0.001 для двох послідовних членів ряду. Задане точне значення ряду fточ(х).
    Вивести кількість ітерацій N, при яких була досягнута точність eps.

    Опис програмы: програма обраховує точно значення ряду и точної функціі.	Точність до епсилон.
    Виводить таблицю на єкран де написані усі значення и кількість ітерацій.
    Виконав студент 2 курсу: Зуєв Михайло Олександрович

"""

import math
import matplotlib.pyplot as plt
import numpy
import scipy.special


def series(x, get_list=False):
    """ Обчислює наближене значення функціонального ряду.

    Для ряду f(x) = 1/x - E(1, oO) (2^(2i) * bernoulli[i] * x^(2i - 1)) / (2i)!, де bernoulli[i] - числа Бернуллі
    обчислити його наближене значення. Обчислення припинити, якщо |a[i]| < eps = 0.001 для двох
    послідовних членів ряду (Або коли кількість ітерацій стає більшою за 11, тому що використувуються
    лише 11 перших чисел Бернуллі).

    Args:
       x: аргумент, для якого потрібно порахувати ряд.
       get_list: якщо цей параметр True, то також повертається список зі значеннями a_i
    Returns:
       Функція завжди повертає два значення: обчисленний функціональний ряд і кількість ітерацій.
       Якщо аргумент getList == True, то також повертається список зі значеннями елементів ряду a_i
       на кожній ітерації.
    """

    # Константи
    eps = 0.001
    x2 = x * x
    bernoulli = scipy.special.bernoulli(12)
    flag = True  # Використовується, щоб для виходу з циклу умова виконалась два рази підряд

    alist = []  # список зі значеннями ai

    # Обчислюємо перший елемент ряду і додаємо його до суми
    i = 1
    a = x / 3
    if get_list:
        alist.append(a)
    summ = a

    while math.fabs(a) >= eps or flag:
        # Таким чином вихід з циклу виконається тільки якщо два послідовних члена ряду
        # будуть меньші за eps
        if math.fabs(a) >= eps:
            flag = True
        else:
            flag = False
        i += 1
        # Для обчислення кожного елементу ряду використувується рекурентна формула
        a *= (2 * x2 * bernoulli[i]) / ((2 * i - 1) * i)
        if get_list:
            alist.append(a)
        summ += a

    if get_list:
        return 1 / x - summ, i, alist
    return 1 / x - summ, i


def ctg(x):
    """ Обчислює значення cos(x).
    # WARNING: Для значення х, при якому sin(x) == 0 виникне помилка.
    """
    return math.cos(x) / math.sin(x)


# Списки з аргумментами та значеннями функцій для графіку
xlist = []
fxList = []
ftList = []
# Вивід шапки таблиці
print("  x  |   Sum  |   ctg  |   f-f  |  N  |")
# Рахуємо значення функціонального ряду та точної функції на проміжку x є (0, 1]
# з кроком h = 0.5. Виводимо ці значення в таблицю та малюємо графіки.
for x in range(5, 101, 5):
    x = x / 100
    xlist.append(x)
    fx, n = series(x)  # Значення функціонального ряду та кількість ітерацій
    ft = ctg(x)  # Точне значення
    fxList.append(fx)
    ftList.append(ft)
    print("%3.2f | %6.3f | %6.3f | %6.1f | %3d |" % (x, fx, ft, (fx - ft) / fx * 100, n))

# Графіки y = f(x) и y = f_точне(x)
plt.subplot(1, 2, 1)
plt.plot(xlist, fxList, xlist, ftList)
plt.xlabel(r'$x$')
plt.ylabel(r'$y$')
plt.title(r'$f_1(x)=\ f(x),\ f_2(x)=\ ctg(x)$')

# Графік y = a_i, для x = 0.5
fx, n, A = series(0.5, True)
plt.subplot(1, 2, 2)
ilist = numpy.arange(1, n + 1, 1)
plt.plot(ilist, A)
plt.xlabel(r'$i$')
plt.ylabel(r'$y$')
plt.title(r'$y=\ a(i),$')
plt.show()
